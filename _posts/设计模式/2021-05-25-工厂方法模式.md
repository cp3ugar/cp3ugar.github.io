---
layout: post
title: "设计模式-创建型模式-工厂方法模式"
date: 2021-05-25
excerpt: "虚拟构造函数、Virtual Constructor、Factory Method"
tags: [Design Patterns,Professional Knowledge]
comments: true

---

# 意图

**工厂方法模式**是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。

![image-20210525174853947](../../assets/img/image-20210525174853947.png)

# 问题

假设你正在开发一款物流管理应用。最初版本只能处理卡车运输，因此绝大部分代码都在位于名为`卡车`的类中。

一段时间后，这款应用变得极受欢迎。你每天都能收到十几次来自海运公司的请求，希望应用能够支持海上物流功能。

![image-20210525175123731](../../assets/img/image-20210525175123731.png)

代码问题该如何处理呢？目前，大部分代码都与`卡车`类相关。在程序中添加`轮船`类需要修改全部代码。更糟糕的是，如果以后需要在程序中支持另外一种运输方式，很可能需要再次对这些代码进行大幅修改。

最后，你将不得不编写繁复的代码，根据不同的运输对象类，在应用中进行不同的处理。

# 解决方案

工厂方法模式建议使用特殊的工厂方法代替对于对象构造函数的直接调用。对象仍将通过`new`运算符创建，只是该运算符改在工厂方法中调用罢了。工厂方法返回的对象通常被称为“产品”。

![image-20210525175646738](../../assets/img/image-20210525175646738.png)

乍看之下，这种更改可能毫无意义：我们只是改变了程序中调用构造函数的位置而已。但是，仔细想一下，现在你可以在子类中重写工厂方法，从而改变其创建产品的类型。

但是有一点需要注意：仅当这些产品具有共同的基类或者接口时，子类才能返回不同类型的产品，同时基类中的工厂方法还应将其返回类型声明为这一共有接口。

![image-20210525180002898](../../assets/img/image-20210525180002898.png)

举例来说，`卡车Truck`和`轮船Ship`类都必须实现`运输Transport`接口，该接口声明了一个名为`deliver交付`的方法。每个类都将以不同的方法实现该方法：卡车走陆路交付货物，轮船走海路交付货物。`陆路运输RoadLogistics`类中的工厂方法返回卡车对象，而`海路运输SeaLogistics`类则返回轮船对象。

![image-20210525180226755](../../assets/img/image-20210525180226755.png)

调用工厂方法的代码（通常被称为客户端代码）无需了解不同子类返回实际对象之间的差别。客户端将所有产品视为抽象的`运输`。客户端知道所有运输对象都提供`交付`方法，但是并不关心其具体实现方式。

# 工厂方法模式结构



![image-20210525180503637](../../assets/img/image-20210525180503637.png)

# 工厂方法模式适合应用场景

### 当你在编写代码的过程中，如果无法预知对象确切类别及其依赖关系时，可使用工厂方法。

工厂方法将创建产品的代码与实际使用产品的代码分离，从而能在不影响其他代码的情况下扩展产品创建部分代码。

例如，如果需要向应用中添加一种新产品，你只需要开发新的创建者子类，然后重写其工厂方法即可。

### 如果你希望用户能扩展软件库或框架的内部组件，可使用工厂方法。

继承可能是扩展软件库或框架默认行为的最简单方法。但是当你使用子类替代标准组件时，框架如何辨识出该子类？

解决方案是将各框架中构造组件的代码集中到单个工厂方法中，并在继承该组件之外允许任何人对该方法进行重写。

### 如果你希望复用现有对象来节省系统资源，而不是每次都重新创建对象，可使用工厂方法。

在处理大型资源密集型对象（如数据库连接、文件系统和网络资源）时，你会经常碰到这种资源需求。

让我们思考复用现有对象的方法：

1. 首先，你需要创建存储空间来存放所有以创建的对象
2. 当他人请求一个对象时，程序将在对象池中搜索可用对象
3. 然后将其返回给客户端代码
4. 如果没有可用对象，程序则创建一个新对象（并将其添加到对象池中）

这些代码必不可少！而且它们必须位于同一处，这样才能确保重复代码不会污染程序。

可能这是最显而易见，也是最方便的方式，就是将这些代码放置在我们试图重用的对象类的构造函数中。但是从定义上来讲，构造函数始终返回的是**新对象**，其无法返回现有实例。

因此，你需要有一个既能够创建新对象，又可以重用现有对象的普通方法。这听起来和工厂方法非常相像。

# 实现方式

1. 让所有产品都遵循同一接口。该接口必须声明对所有产品都有意义的方法。

2. 在创建类中添加一个空的工厂方法。该方法的返回类型必须遵循通用的产品接口。

3. 在创建者代码中找到对于产品构造函数的所有引用。将它们依次替换为对于工厂方法的调用，同时将创建产品的代码移入工厂方法。你可能需要在工厂方法中添加临时参数来控制返回的产品类型。

   工厂方法的代码看上去可能非常糟糕。其中可能会有复杂的`switch分支`运算符，用于选择各种需要实例化的产品类。但是不要担心，我们很快就会修复这个问题。

4. 现在，为工厂方法中的每种产品编写一个创建者子类，然后在子类中重写工厂方法，并将基本方法中的相关创建代码移动到工厂方法中。

5. 如果应用中的产品类型太多，那么为每个产品创建子类并无太大必要，这时你也可以在子类中复用基类中的控制参数。

   例如，设想你有以下一些层次结构的类。基类`邮件`及其子类`航空邮件`和`陆路邮件`；`运输`及其子类`飞机`，`卡车`和`火车`。`航空邮件`仅使用`飞机`对象，而`陆路邮件`则会同时使用`卡车`和`火车`对象。你可以编写一个新的子类（例如`火车邮件`）来处理这两种情况，但是还有可选的方法。客户端代码可以给`陆路邮件`类传递一个参数，用于控制其希望获得的产品。

6. 如果代码经过上述移动后，基础工厂方法中已经没有任何代码，你可以将其转变为抽象类。如果基础工厂方法中还有其他语句，你可以将其设置为该方法的默认行为。

# 工厂方法模式优缺点

优点：

- 可以避免创建者和具体产品之间的紧密耦合
- 单一职责原则。你可以将产品创建代码放在程序的单一位置，从而使得代码更容易维护
- 开闭原则。无需更改现有客户端代码，你就可以在程序中引入新的产品类型

缺点：

- 应用工厂方法模式需要引入许多新的子类，代码可能会因此变得复杂。最好的情况是将该模式引入创建者类的现有层次结构中

# 与其他模式的关系

- 在许多设计工作的初期都会使用**<u>工厂方法模式</u>**，随后演化为使用**<u>抽象工厂模式</u>**、**<u>原型模式</u>**或**<u>生成器模式</u>**。
- **<u>抽象工厂模式</u>**通常基于一组**<u>工厂方法</u>**，但你也可以使用**<u>原型模式</u>**来生成这些类的方法。
- 你可以同时使用**<u>工厂方法</u>**和**<u>迭代器模式</u>**来让子类集合返回不同类型的迭代器，并使得迭代器与集合相匹配。
- **<u>原型</u>**并不基于继承，因此没有继承的缺点。另一方面，原型需要对被复制对象进行复杂的初始化。**<u>工厂方法</u>**基于继承，但是不需要初始化步骤。
- **<u>工厂方法</u>**是**<u>模板方法模式</u>**的一种特殊形式。同时，工厂方法可以作为一个大型模板方法中的一个步骤。



> [摘自REFACTORING GURU](https://refactoringguru.cn/design-patterns/factory-method)

# 代码示例

首先，我们先来看一下简单工厂模式。简单工厂模式有一个具体的工厂类（创建者），可以生成多个不同的产品，属于创建型设计模式。简单工厂模式不在 GoF 23 种设计模式之列。如果要创建的产品不多，只要一个工厂类就可以完成，这个时候我们可以使用简单工厂模式。

简单工厂模式的主要角色有：

- 简单工厂（SimpleFactory）：简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以直接被客户端调用，创建所需产品对象。
- 抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。
- 具体产品（ConcreteProduct）：是简单工厂模式的创建目标。

我们此处用服装厂为例。

首先定义一个抽象产品类：

```java
public interface Clothing {
    /**
     * 售卖
     */
    void sale();
}
```

然后定义具体产品，并实现抽象产品：

```java
public class Jeans implements Clothing{
    @Override
    public void sale() {
        System.out.println("卖牛仔裤");
    }
}
```

```java
public class TShirt implements Clothing{
    @Override
    public void sale() {
        System.out.println("卖T恤");
    }
}
```

最后定义工厂类：

```java
public class ClothesFactory {
    enum ClothesEnum{
        TSHIRT, JEANS
    }

    public static Clothing getClothes(ClothesEnum clothesEnum){
        if(clothesEnum.equals(ClothesEnum.TSHIRT)){
            return new TShirt();
        }else if(clothesEnum.equals(ClothesEnum.JEANS)){
            return new Jeans();
        }else{
            return null;
        }
    }
}
```

客户端代码：

```java
public class Demo {
    public static void main(String[] args) {
        Clothing c1 = ClothesFactory.getClothes(ClothesFactory.ClothesEnum.JEANS);
        c1.sale();
        Clothing c2 = ClothesFactory.getClothes(ClothesFactory.ClothesEnum.TSHIRT);
        c2.sale();
    }
}

//卖牛仔裤
//卖T恤
```

可以看出，简单工厂模式一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂，这增加了系统的复杂度，违背了“开闭原则”。

工厂方法模式是对简单工厂模式的进一步抽象，其好处是可以是系统在不修改原来代码的情况下增加新的产品，满足开闭原则。

下面还是以服装厂为例，对其进行改造，使其成为工厂方法模式。

首先，对工厂类进行抽象，定义一个抽象工厂类。

```java
public abstract class Factory {
    public void saleClothes(){
        Clothing clothing = getClothes();
        clothing.sale();
    }

    /**
     * 获取衣服
     * @return
     */
    public abstract Clothing getClothes();
}
```

定义具体的工厂类：

```java
public class TShirtFactory extends Factory{
    @Override
    public Clothing getClothes() {
        return new TShirt();
    }
}
```

```java
public class JeansFactory extends Factory{
    @Override
    public Clothing getClothes() {
        return new Jeans();
    }
}
```

客户端代码：

```java
public class Demo {
    public static void main(String[] args) {
        JeansFactory jeansFactory = new JeansFactory();
        jeansFactory.saleClothes();

        TShirtFactory tShirtFactory = new TShirtFactory();
        tShirtFactory.saleClothes();
    }
}

//卖牛仔裤
//卖T恤
```

